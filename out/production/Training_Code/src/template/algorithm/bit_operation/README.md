
---

## 位运算基础知识

位运算是计算机处理二进制数的基础操作之一，它在处理底层数据时非常高效。以下是几种常见的位运算符及其用法：

### 1. "与" (AND) - `x & y`
- **功能**: 按位进行“与”运算，当且仅当两个对应的位都为1时，结果为1，否则为0。
- **示例**:
  ```plaintext
  x = 5 (0101)
  y = 3 (0011)
  x & y = 1 (0001)
  ```

### 2. "或" (OR) - `x | y`
- **功能**: 按位进行“或”运算，只要两个对应的位中有一个为1，结果即为1。
- **示例**:
  ```plaintext
  x = 5 (0101)
  y = 3 (0011)
  x | y = 7 (0111)
  ```

### 3. "非" (NOT) - `!x`
- **功能**: 按位进行“非”运算，将每一位取反。1变0，0变1。
- **示例**:
  ```plaintext
  x = 5 (0101)
  !x = -6 (1010)
  ```

### 4. "异或" (XOR) - `x ^ y` (不进位加法)
- **功能**: 按位进行“异或”运算，当且仅当两个对应的位不同，结果为1。
- **示例**:
  ```plaintext
  x = 5 (0101)
  y = 3 (0011)
  x ^ y = 6 (0110)
  ```

---

## `int32` 数据类型

在32位整数类型中，位运算的结果与数值的符号位密切相关。理解正负数的二进制表示形式可以帮助更好地使用位运算。

### 正数表示
- **最高位为0**: 在32位整数的二进制表示中，正数的最高位为0，其余31位表示数值。

### 负数表示
- **最高位为1**: 负数采用补码形式表示，最高位为1，表示该数为负。

---

## 补码 (Two's Complement) 概念

补码是一种用于表示负数的编码方式。计算机采用补码来进行加减运算，补码的特点是负数的最高位为1，而正数的最高位为0。以下是补码的基本概念：

1. **正数的补码表示**: 与原码相同。正数的补码和二进制表示是一致的。
    - 例如：`5` 的补码是 `00000000 00000000 00000000 00000101`。

2. **负数的补码表示**:
    - 将该数的原码按位取反（0变1，1变0）。
    - 取反后，再加1得到补码。
    - 例如：`-5` 的补码是 `11111111 11111111 11111111 11111011`。

### 补码的作用：
- 补码可以将减法转换为加法，从而简化计算机的运算规则。比如，计算 `5 - 3` 实际上可以转换为 `5 + (-3)`，使用补码运算更加高效。
- **减法变加法**: 使用补码，减去一个数相当于加上它的补码。因为补码能够统一处理加减运算，计算更加简便。

### 示例:
- **正数和负数的补码运算**:
  ```plaintext
  5  的二进制:  00000000 00000000 00000000 00000101
  -5 的补码:  11111111 11111111 11111111 11111011
  5 + (-5) = 0: 
  00000000 00000000 00000000 00000101
  + 11111111 11111111 11111111 11111011
  = 00000000 00000000 00000000 00000000
  ```

---

通过这些位运算符和补码的概念，可以更高效地处理二进制数据和数学运算。

---

Here is the raw markdown:

```markdown
## 位运算基础知识

位运算是计算机处理二进制数的基础操作之一，它在处理底层数据时非常高效。以下是几种常见的位运算符及其用法：

### 1. "与" (AND) - `x & y`
- **功能**: 按位进行“与”运算，当且仅当两个对应的位都为1时，结果为1，否则为0。
- **示例**:
  ```plaintext
  x = 5 (0101)
  y = 3 (0011)
  x & y = 1 (0001)
  ```

### 2. "或" (OR) - `x | y`
- **功能**: 按位进行“或”运算，只要两个对应的位中有一个为1，结果即为1。
- **示例**:
  ```plaintext
  x = 5 (0101)
  y = 3 (0011)
  x | y = 7 (0111)
  ```

### 3. "非" (NOT) - `!x`
- **功能**: 按位进行“非”运算，将每一位取反。1变0，0变1。
- **示例**:
  ```plaintext
  x = 5 (0101)
  !x = -6 (1010)
  ```

### 4. "异或" (XOR) - `x ^ y` (不进位加法)
- **功能**: 按位进行“异或”运算，当且仅当两个对应的位不同，结果为1。
- **示例**:
  ```plaintext
  x = 5 (0101)
  y = 3 (0011)
  x ^ y = 6 (0110)
  ```

---

## `int32` 数据类型

在32位整数类型中，位运算的结果与数值的符号位密切相关。理解正负数的二进制表示形式可以帮助更好地使用位运算。

### 正数表示
- **最高位为0**: 在32位整数的二进制表示中，正数的最高位为0，其余31位表示数值。

### 负数表示
- **最高位为1**: 负数采用补码形式表示，最高位为1，表示该数为负。

---

## 补码 (Two's Complement) 概念

补码是一种用于表示负数的编码方式。计算机采用补码来进行加减运算，补码的特点是负数的最高位为1，而正数的最高位为0。以下是补码的基本概念：

1. **正数的补码表示**: 与原码相同。正数的补码和二进制表示是一致的。
    - 例如：`5` 的补码是 `00000000 00000000 00000000 00000101`。

2. **负数的补码表示**:
    - 将该数的原码按位取反（0变1，1变0）。
    - 取反后，再加1得到补码。
    - 例如：`-5` 的补码是 `11111111 11111111 11111111 11111011`。

### 补码的作用：
- 补码可以将减法转换为加法，从而简化计算机的运算规则。比如，计算 `5 - 3` 实际上可以转换为 `5 + (-3)`，使用补码运算更加高效。
- **减法变加法**: 使用补码，减去一个数相当于加上它的补码。因为补码能够统一处理加减运算，计算更加简便。

### 示例:
- **正数和负数的补码运算**:
  ```plaintext
  5  的二进制:  00000000 00000000 00000000 00000105
  -5 的补码:  11111111 11111111 11111111 11111011
  5 + (-5) = 0: 
  00000000 00000000 00000000 00000105
  + 11111111 11111111 11111111 11111011
  = 00000000 00000000 00000000 00000000
  ```

---

通过这些位运算符和补码的概念，可以更高效地处理二进制数据和，在计算机竞赛中，比较常见补码的计算方式为 `~x + 1`,因此当x大于0时 `-x = ~x + 1`.
巧妙地将减法操作或者负数项变成了计算机擅长的取反操作和加法操作。

---

### 竞赛常用小技巧
`memset(f, 0x3F, sizeof f)` 是在c++中创建数组时给数组每个元素赋予最大值用于求最小/优值。
因为4个字节的`0x3f3f3f3f * 2`小于`0xffff`不会溢出

#### 左移与右移
- `1 << n` 相当于 `2^n`
- `n >> x` 相当于 `n/(2^x)`,这里注意区分算术右移和逻辑右移 \
逻辑右移直接直接补0，算数右移根据最高位决定，负数补1，正数补0

#### 取模运算的性质
##### 1. 加法的模运算
```plaintext
(a + b) mod m = [(a mod m) + (b mod m)] mod m
```
**解释**: 两个数的和取模，等于先分别对它们取模后再相加，再对结果取模。

##### 2. 减法的模运算
```plaintext
(a - b) mod m = [(a mod m) - (b mod m) + m] mod m
```
**解释**: 两个数的差取模，等于先分别对它们取模后再相减，为了避免负数，通常加上一个 m 再取模。

##### 3. 乘法的模运算
```plaintext
(a * b) mod m = [(a mod m) * (b mod m)] mod m
```
**解释**: 两个数的乘积取模，等于分别对它们取模后相乘，再对结果取模。

##### 4. 幂运算的模运算
```plaintext
(a^b) mod m = [(a mod m)^b] mod m
```
**解释**: 幂运算的取模可以通过快速幂算法来高效计算。

##### 5. 结合律
```plaintext
(a + (b + c)) mod m = ((a + b) + c) mod m
(a * (b * c)) mod m = ((a * b) * c) mod m
```
**解释**: 模运算支持加法和乘法的结合律。

##### 6. 交换律
```plaintext
(a + b) mod m = (b + a) mod m
(a * b) mod m = (b * a) mod m
```
**解释**: 模运算支持加法和乘法的交换律。

##### 7. 分配律
```plaintext
(a * (b + c)) mod m = [(a * b) mod m + (a * c) mod m] mod m
```
**解释**: 模运算支持乘法对加法的分配律。

##### 8. 负数的模运算
```plaintext
(-a) mod m = (m - (a mod m)) mod m
```
**解释**: 负数取模后，结果为非负数。

---
## 题目知识点地图
1. `快速幂` or `"Fast Exponentiation"` -> reducing the time complexity of exponentiation from  O(n) to O(log n).\
- **Follow Up**
- `Bit64Multiplication`

